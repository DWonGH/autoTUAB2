import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import cm
import argparse

default_columns_to_ignore = ['tueg', 'saved_windows_data', 'saved_windows_path', 'load_saved_data', 'load_saved_windows',
                             'tmin', 'tmax', 'window_stride_samples',
                             'lr', 'batch_size', 'n_epochs', 'duration_recording_sec']


parser = argparse.ArgumentParser()

parser.add_argument("--input", default='result.csv',
                    help="result.csv file generated by train_and_eval.py")
parser.add_argument("--column_of_interest", default='acc_per_recording',
                    help="Which values to plot on the y-axis.")
parser.add_argument("--columns_to_ignore", default=default_columns_to_ignore,
                    help="Which columns to exclude from the analysis.")

def boxplot_with_scatter(grouped, column_of_interest):
    """ From groupby object 'grouped' create boxplot with superimposed scatter plot of 'column_of_interest' """

    # Gather the data from each group
    names, vals, xs = [], [], []
    for i, (name, subdf) in enumerate(grouped):
        names.append(name)
        vals.append(subdf[column_of_interest].tolist())
        xs.append(np.random.normal(i + 1, 0.04, subdf.shape[0]))

    # plot boxplot
    plt.boxplot(vals, labels=names)
    ngroup = len(vals)
    clevels = np.linspace(0., 1., ngroup)

    # plot scatter points on top of boxplot
    for x, val, clevel in zip(xs, vals, clevels):
        plt.scatter(x, val, c=cm.prism(clevel), alpha=0.4)

    plt.xticks(rotation=45)
    plt.tight_layout()

def analyse(ff, column_of_interest, columns_to_ignore):

    # load data from results.csv
    results = pd.read_csv(ff)
    # If that looks wrong, try skipping first row:
    if results.shape[1] == 1:
        results = pd.read_csv(ff, header=1)

    # drop rows with fewer than 5 entries
    results = results.dropna(thresh=5)

    # drop rows that repeate the header row
    results = results[results.iloc[:, 0] != results.columns[0]]

    # drop columns that are not of interest
    results = results.drop(columns_to_ignore, axis=1)

    # Identify columns with more than 1 unique value (ignoring first 10 columns and last 5 columns)
    cols = results.columns[10:-5]
    varied_cols = [col for col in cols if results[col].nunique() > 1]

    # Replace all entries in 'channels' column with 'with A1/A2' if 'channels' column contains 'A1' or 'A2'. Otherwise
    # replace with 'without A1/A2':
    if 'channels' in varied_cols:
        chan_str_1 = "['EEG A1-REF', 'EEG A2-REF', 'EEG FP1-REF', 'EEG FP2-REF', 'EEG F3-REF', 'EEG F4-REF', 'EEG C3-REF', 'EEG C4-REF', 'EEG P3-REF', 'EEG P4-REF', 'EEG O1-REF', 'EEG O2-REF', 'EEG F7-REF', 'EEG F8-REF', 'EEG T3-REF', 'EEG T4-REF', 'EEG T5-REF', 'EEG T6-REF', 'EEG FZ-REF', 'EEG CZ-REF', 'EEG PZ-REF']"
        chan_str_2 = "['EEG FP1-REF', 'EEG FP2-REF', 'EEG F3-REF', 'EEG F4-REF', 'EEG C3-REF', 'EEG C4-REF', 'EEG P3-REF', 'EEG P4-REF', 'EEG O1-REF', 'EEG O2-REF', 'EEG F7-REF', 'EEG F8-REF', 'EEG T3-REF', 'EEG T4-REF', 'EEG T5-REF', 'EEG T6-REF', 'EEG FZ-REF', 'EEG CZ-REF', 'EEG PZ-REF']"
        results['channels'] = results['channels'].replace([chan_str_1], 'with A1/A2')
        results['channels'] = results['channels'].replace([chan_str_2], 'without A1/A2')

    # Make sure column_of_interest is numeric
    results[column_of_interest] = pd.to_numeric(results[column_of_interest])

    # create box plots of 'accuracy', grouping by 'model_name' and 'channels'
    results.boxplot(column=column_of_interest, by=varied_cols)
    plt.draw()

    # Alternative version with superimposed scatter
    plt.figure()
    grouped = results.groupby(varied_cols)

    boxplot_with_scatter(grouped, column_of_interest)
    plt.draw()

# Press the green button in the gutter to run the script.
if __name__ == '__main__':

    args = parser.parse_args()

    analyse(args.input, args.column_of_interest, args.columns_to_ignore)

    plt.show()
